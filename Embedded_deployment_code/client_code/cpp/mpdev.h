/*! \file mpdev.h
	\author BIOPAC Systems, Inc.
	\version 2.2.1
    \brief  The BIOPAC Hardware API allows third-party software programs to communicate with BIOPAC MP devices

	The Hardware API is compatible with the MP150 communicating via Ethernet using UDP and the MP36R communicating via USB.

	The Hardware API allows developers to create software programs that communicate directly to the MP device.

	Using the Hardware API functions, software developers can:
  
	- Acquire data from the analog and digital channels
	- Acquire at different sample rates
	- Set triggers
	- Get the MP device status
	- Use the Analog output channels 

	New Features:
	- Added MP160 support
*/

#ifndef _MPDEV_H_
#define _MPDEV_H_

#include <windows.h>

/** Enumerated Values for MP Devices
 * 
 *	Represents supported MP devices.
 *
 */
typedef enum MP_TYPE
{
	MP150 = 101,	/**< represents the MP150 device */
//	MP35,			/**< represents the MP35 device */
	MP36,			/**< represents the MP36R device */
	MP160			/**< represents the MP160 device */
} MPTYPE;

/** Enumerated Values for the MP Device Communication Types
 *
 *  Represents supported MP communication types.
 *
 */
typedef enum MP_COM_TYPE
{
	MPUSB = 10, /**< represents communication via USB */
	MPUDP		/**< represents communication via Ethernet using UDP */
} MPCOMTYPE;

/** Enumerated Values For MP Device Triggering Options
 *
 *  Represents supported MP triggering options. 
 *
 */
typedef enum TRIGGER_OPT
{
	MPTRIGOFF = 1, /**< represents triggering off */
	MPTRIGEXT,	/**< represents external triggering */
	MPTRIGACH,	/**< represents analog channel triggering */
	MPTRIGDCH	/**< represents digital channel triggering (MP36R only)*/
} TRIGGEROPT;

/** Enumerated Values For the MP Device Digital I/O Options
 *
 *  Represents supported MP digital line reading or writing options. 
 *
 */
typedef enum DIGITAL_OPT
{
	SET_LOW_BITS = 1, /**< set only digital I/O lines 0 through 7 */
	SET_HIGH_BITS, /**< set only digital I/O lines 8 through 15 */
	READ_LOW_BITS, /**< read only digital I/O lines 0 through 7 */
	READ_HIGH_BITS /**< read only digital I/O lines 8 through 15 */
} DIGITALOPT;

/** Enumerated Return Code Values
 *
 *  Return codes that are generated by Hardware API functions. 
 *
 */
typedef enum MP_RETURN_CODE
{
	MPSUCCESS = 1, /**< = successful execution */
	MPDRVERR,	/**< = error communicating with the device drivers*/
	MPDLLBUSY,	/**< = a process is attached to the DLL, only one process may use the DLL */
	MPINVPARA,	/**< = invalid parameter(s)*/
	MPNOTCON,	/**< = MP device is not connected */
	MPREADY,	/**< = MP device is ready */
	MPWPRETRIG, /**< = MP device is waiting for pre-trigger (pre-triggering is not implemented) */
	MPWTRIG,	/**< = MP device is waiting for trigger */
	MPBUSY,		/**< = MP device is busy */
	MPNOACTCH,	/**< = there are no active channels, in order to acquire data at least one analog channel must be active */
	MPCOMERR,	/**< = generic communication error */
	MPINVTYPE,	/**< = the function is incompatible with the selected MP device or communication method */
	MPNOTINNET,	/**< = the specified MP150 is not in the network  */
	MPSMPLDLERR,/**< = MP device overwrote samples that had not been transferred from the device (buffer overflow) */
	MPMEMALLOCERR, /**< = error allocating memory */
	MPSOCKERR,	/**< = internal socket error */
	MPUNDRFLOW, /**< = MP device returned a data pointer that is less than the last data pointer **/
	MPPRESETERR, /**< = error with the specified preset file **/
	MPPARSERERR	/**< = preset file parsing error, the XML file must be valid according to the schema **/
} MPRETURNCODE;

/** Enumerated Values For MP36R Device Ouput modes
 *
 *  Represents supported MP36R output modes. 
 *
 */
typedef enum MP3XOUTPUT_OPT
{
	OUTPUTVOLTAGELEVEL		= 2, /**< = Setup ouptput mode to CONSTANT VOLTAGE LEVEL (MP36R does not support this mode) */
	OUTPUTCHANNEL3			= 3, /**< = Redirect input channel #3 to output  */
//	OUTPUTSTIMULATOR		4,	// Not supported with BHAPI 2.1
	OUTPUTCHANNEL1			= 5, /**< = Redirect input channel #1 to output  */
	OUTPUTCHANNEL2			= 6, /**< = Redirect input channel #2 to output  */
	OUTPUTCHANNEL4			= 7, /**< = Redirect input channel #4 to output  */
	OUTPUTGROUND			= 0x7f /**< = Ground all output signal - setup output sugnal to zero level */
} MP3XOUTMODE;


/** Attribute that enables the export of API functions via a DLL  **/
#define MPDLL_EXPORT __declspec(dllexport) 

#ifdef __cplusplus
extern "C"
{
#endif

/** Configure a Channel by Preset ID
 *
 *	This function will configure an analog input channel based on the preset element with the specified unique ID (uid) from the XML preset file loaded into memory using the loadXMLPresetFile() function.
 *
 *	Please see \ref chpresetxml_page.
 *
 *	\note
 *		- For the MP36R, the Scaling and the Hardware Configuration elements are applied 
 *		- For the MP150 and MP160, only the Scaling element is applied
 *
 *	\param n the analog input channel where the preset configuration will be applied and 0 &lt;= <em>n</em> &lt; number of analog input channels of the MP device
 *	\param uid the unique identifier of the preset to be applied to the specified channels
 *  
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall configChannelByPresetID(const DWORD n, const char * uid);

/** Connect to the Specified MP Device
 *
 *	This function MUST be called first when using the Hardware API.
 *
 *	\note
 *		- This function will connnect to the first responding MP150 or MP160, when "AUTO" or "auto" is specified for the <em>MP150SN</em> parameter
 *		- The first responding MP150/MP160 is usually the closest MP150/MP160 but it is not guaranteed
 *		- The MP150 serial number can be obtained using findAllMP150() and readAvailableMP150SN()
 *		- The MP160 serial number can be obtained using findAllMP160() and readAvailableMP160SN()
 *
 *	\param type the type of device to connect with, must use <em>MPTYPE</em> enumerated values
 *	\param method the type of communication method, must use <em>MPCOMTYPE</em> enumerated values
 *	\param MP150SN can be set to any string if using the MP36R, otherwise it's the serial number of the MP150 or MP160. "AUTO" or "auto" can be used to automatically connect to first MP150/MP160 to respond
 *
 *	\return <em>MPRETURNCODE</em>
 */

 /*
  *
type (MPTYPE): 指定要连接的设备类型。这个参数必须使用MPTYPE枚举中的值。MPTYPE枚举可能包括不同类型的BIOPAC设备，如MP150或MP160等。

method (MPCOMTYPE): 指定通信方法的类型。这个参数必须使用MPCOMTYPE枚举中的值。MPCOMTYPE枚举定义了不同的通信方式，比如通过USB、Wi-Fi或其他连接方式。

MP150SN (const char *): 如果使用的是MP36R设备，这个参数可以设置为任意字符串。对于MP150或MP160设备，这里应该填写设备的序列号。
  如果你想自动连接到第一个响应的MP150或MP160设备，可以使用字符串"AUTO"或"auto"。序列号可以通过findAllMP150()和readAvailableMP150SN()函数（对于MP150设备），
  或者findAllMP160()和readAvailableMP160SN()函数（对于MP160设备）来获取。
  * */
MPDLL_EXPORT MPRETURNCODE _stdcall connectMPDev(const MPTYPE type, const MPCOMTYPE method, const char * MP150SN);

/** Disconnect from the MP Device
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall disconnectMPDev();

/** Find All MP160s
 *
 *	Finds all the MP160s routable in the current network configuration and caches their serial numbers which can be read by calling readAvailableMP160SN().
 *
 *	\note
 *		- connectMPDev() must be called first
 *		- the call to connectMPDev() must FAIL because of an invalid serial number
 *		- only works with device type <em>MP160</em> and communication type <em>MPUDP</em>
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall findAllMP160();

/** Find All MP150s
 *
 *	Finds all the MP150s routable in the current network configuration and caches their serial numbers which can be read by calling readAvailableMP150SN().
 *
 *	\note
 *		- connectMPDev() must be called first
 *		- the call to connectMPDev() must FAIL because of an invalid serial number
 *		- only works with device type <em>MP150</em> and communication type <em>MPUDP</em>
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall findAllMP150();

/** Get a Channel's Scaled Input Range
 *
 *	This function calculates the scaled input range of a particular channel.
 *  The Scaled Input Range is the scaled range of double values where the MP device can successfully read a scaled sample value without clipping.
 *	It is depedent upon scaling, gain, and offset values of the specified analog input channel.
 *	If the scaled sample value is out of the range, it will be clipped to the range's maximum or minimum value.  
 *
 *	\param n the analog input channel where the scaled channel input range will be calculated and 0 &lt;= <em>n</em> &lt; number of analog input channels of the MP device
 *	\param minRange an out variable where the minimum value of the scaled input range is stored
 *	\param maxRange an out variable where the maximum value of the scaled input range is stored
 *  
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall getChScaledInputRange(const DWORD n, double * minRange, double * maxRange);

/** Get the State of the Specified Digital I/O Line
 *
 *	<em>true</em> = "high" = 1 = 5.0 volts (TTL high)
 *	\n
 *	<em>false</em> = "low" = 0 = 0.0 volts (TTL low)
 *
 *	\note	
 *		- The MP36R has dedicated input and output lines while the MP150 has auto-switching digital input and output lines
 *		- For the MP150/MP160, this function automatically switches the direction of all the Digital I/O lines to input
 *		- The MP36R has 8 digital input lines (digital lines 0 through 7)
 *		- The MP150/MP160 has 16 digital input lines (digital lines 0 through 15)
 *
 *	\param n the Digital Input channel to get  where 0 &lt;= <em>n</em> &lt; number of digital input channels of the MP device
 *	\param state an out variable where the state of Digital Input line <em>n</em> is stored
 *	\param opt
 *	    if <em>opt</em> == <em>READ_LOW_BITS</em> and 0 &lt;= <em>n</em> &lt; 8 only digital lines 0-7 are read\n
 *	    if <em>opt</em> == <em>READ_HIGH_BITS</em> and 8 &lt;= <em>n</em> &lt; 16 only digital lines 8-15 are read\n
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall getDigitalIO(const DWORD n, BOOL * state, const DIGITALOPT opt);

/** Get the Most Recent Sample
 *
 *	This function blocks until the MP device acquires the most recent sample. Once startAcquisition() is called, the MP device continuously acquires data at the specified sample rate. Use this function to get the latest sample collected at the time it was called. This function is useful in monitoring purposes at low sample rates where previous data does not change rapidly.
 *
 *	\note 
 *		- If acquiring only analog input channels:
 *			- <em>data</em> array must be able to hold double values equivalent to number of analog input channels of the MP device
 *			- After this function is succesfully invoked, data[<em>i</em>] = the most recent sample of the Analog Input Channel <em>i</em>+1, where 0 &lt;= <em>i</em> &lt; the number of analog input channels of the MP device
 *			- If a channel is not enabled for acquisition the corresponding array element will not be set to a default value
 *		- If acquiring analog and digital channels:
 *			- <em>data</em> array must be able to hold double values equivalent to number of analog input channels plus the number of digital input channels of the MP device
 *			- After this function is succesfully invoked, data[<em>i</em>] = the most recent sample of the Analog Input Channel <em>i</em>+1 and data[<em>a+d</em>] = the most recent sample of the Digital Input Channel <em>a+d</em> where:
 *				 - <em>a</em> is the number of analog input channels of the MP device
 *				 - 0 &lt;= <em>i</em> &lt; <em>a</em> 
 *				 - 0 &lt;= <em>d</em> &lt; the number of digital input channels of the MP device
 *			- If a channel is not enabled for acquisition the corresponding array element will not be set to a default value
 *	
 *	\param data an out double array variable where the most recent sample for input channels is stored by the function
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall getMostRecentSample(double data[]);

/** Get the Acquisition Buffer
 *  
 *	This function blocks until the MP device acquires the number of samples requested. The values will be interleaved, which means that the value for each active channel will be adjacent to each other and in increasing order by channel number.
 *	If acquiring with analog and digital channels, data from active digitals channels will follow the analog channels in the same interleaved manner. 
 *
 *  This function should only be used for acquisitions lasting less than a minute.  <b>It must only be called once per acquisition.</b>
 *	
 *	\par
 *  \htmlinclude buffer.txt
 *
 *	\note
 *		- <em>buff</em> array must be able to hold at least <em>numSamples*(number of active analog channels + number of active digital channels )</em> double values
 *
 *	\param numSamples the number of samples to acquire
 *	\param buff an out double array variable where values from the acquisition are stored
 *
 *	\return <em>MPRETURNCODE</em>
 */
 /*
getAcquisitionBuffer函数用于从MP设备获取数据采集缓冲区的内容。此函数在请求的样本数量被采集完毕前将阻塞执行。下面是参数的详细解释及注意事项：

numSamples (int): 需要采集的样本数量。这个参数指定了你希望从MP设备采集的数据样本的数量。
buff (double[]): 一个输出的双精度浮点数数组变量，用于存储采集到的值。这个数组将包含从MP设备采集到的数据。

数据交错:
函数返回的数据是交错的，意味着每个激活通道的值将会相邻排列，且按通道号递增的顺序排列。如果同时采集模拟和数字通道的数据，来自激活的数字通道的数据将会以同样交错的方式紧随模拟通道的数据。
使用限制:
这个函数仅适用于持续时间小于一分钟的数据采集。它在每次采集中只能被调用一次。
注意事项:
buff数组大小：buff数组必须足够大，能够至少容纳numSamples*(激活的模拟通道数 + 激活的数字通道数)个double类型的值。确保在调用此函数之前，已经正确地分配了buff数组的大小，以避免内存溢出或数据丢失。
函数返回值:
返回类型为MPRETURNCODE，这是一个枚举类型，用于指示函数调用的结果。成功获取数据采集缓冲区的内容会返回MPSUCCESS。如果获取失败，将返回一个错误码，指明具体的失败原因。
简而言之，getAcquisitionBuffer函数是在数据采集过程中用于从MP设备获取采集数据的关键函数。它按照交错方式返回所有激活通道的数据，使用时需注意数组大小的分配和函数的调用限制
  * */
MPDLL_EXPORT MPRETURNCODE _stdcall getMPBuffer(const DWORD numSamples, double buff[]);

/** Get the MP Daemon Last Error
 *
 *	This function returns the exit value or the status of the MP Acquisition Daemon that was created by a call to startMPAcqDaemon().
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall getMPDaemonLastError();

/** Get the Status of the MP Device
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall getStatusMPDev();

/** Load an XML Preset File
 *
 *	This function loads an XML preset file into memory.  The XML document must be properly formatted. 
 *
 *	Please see \ref chpresetxml_page.
 *
 *	\param filename the complete filename of the XML file using absolute or relative path
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall loadXMLPresetFile(const char * filename);

/** Read the Serial Numbers of Available MP150s
 *
 *	Reads the serial numbers of MP150s routable in the current network configuration.
 *
 *	\note
 *		- requires a successful call to findAllMP150()
 *		- MP150 serial number normally consist of 12 characters
 *		- each line represents the serial number of a MP150
 *		- each line will normally consist of 13 characters (the serial number and the newline character, '\\n')
 *		- returns <em>MPSUCCESS</em> if it reads one or more characters
 *		- <em>buff</em> array must be able to hold at least <em>numchartoread</em> character values
 *
 *	\param buff an out array variable where the number of requested character to read will be stored 
 *	\param numchartoread the number of characters requested to be read
 *	\param numcharread an out variable where the number of characters actually read is stored
 *
 *	\return <em>MPRETURNCODE</em>
 *
 *	\include readsn.txt
 */
MPDLL_EXPORT MPRETURNCODE _stdcall readAvailableMP150SN(char buff[], const DWORD numchartoread, DWORD * numcharread);

/** Read the Serial Numbers of Available MP160s
 *
 *	Reads the serial numbers of MP160s routable in the current network configuration.
 *
 *	\note
 *		- requires a successful call to findAllMP160()
 *		- MP160 serial number normally consist of 12 characters
 *		- each line represents the serial number of a MP160
 *		- each line will normally consist of 13 characters (the serial number and the newline character, '\\n')
 *		- returns <em>MPSUCCESS</em> if it reads one or more characters
 *		- <em>buff</em> array must be able to hold at least <em>numchartoread</em> character values
 *
 *	\param buff an out array variable where the number of requested character to read will be stored 
 *	\param numchartoread the number of characters requested to be read
 *	\param numcharread an out variable where the number of characters actually read is stored
 *
 *	\return <em>MPRETURNCODE</em>
 *
 *	\include readsn.txt
 */
MPDLL_EXPORT MPRETURNCODE _stdcall readAvailableMP160SN(char buff[], const DWORD numchartoread, DWORD * numcharread);

/** Receive the MP Data
 *
 *	Receives the MP data from the MP Acquisition Daemon. This is recommended for continuous acquisitions. The values will be interleaved, which means that the value for each active channel will be adjacent to each other and in increasing order by channel number. If acquiring with analog and digital channels, data from active digitals channels will follow the analog channels in the same interleaved manner.
 *
 *	\htmlinclude stream.txt
 *
 *	\note
 *		- requires a successful call to startMPAcqDaemon()
 *		- the data will be a stream of double values
 *		- returns <em>MPSUCCESS</em> if it receives one or more double values
 *		- <em>buff</em> array must be able to hold at least <em>numdatapoints</em> double values
 *
 *  \param buff an out array variable where the number of requested double values to receive will be stored
 *	\param numdatapoints the number of values requested to be received from the acquisition daemon
 *	\param numreceived an out variable where the number of double values actually received from the acquisition daemon is stored
 *
 *	\return <em>MPRETURNCODE</em>
 *
 *	\include daemon.txt
 */
/*
receiveMPData函数用于从MP数据采集守护进程接收数据，这个方法特别适合于连续数据采集的场景。
 接收到的值会以交错的方式排列，意味着每个活跃通道的值会相邻排列，并按通道号递增的顺序排列。
 如果同时采集模拟和数字通道，来自活跃的数字通道的数据将会以同样交错的方式紧随模拟通道的数据。

参数详解:
buff (double[]): 一个输出数组变量，用于存储接收到的双精度值。这个数组需要在函数调用之前准备好，并且大小足够存储请求接收的数据点。
numdatapoints (int): 请求从采集守护进程接收的值的数量。这表示你想从守护进程接收多少个双精度数据点。
numreceived (int*或int&): 一个输出变量，用于存储实际从采集守护进程接收到的双精度值的数量。这可以用来确定实际接收到的数据点数量，可能因为各种原因（如缓存不足）少于请求的数量。

注意事项:
启动守护进程: 在调用此函数之前，需要成功调用startMPAcqDaemon()函数来启动数据采集守护进程。
数据格式: 接收到的数据将是双精度值（double）的流。
返回值: 如果函数成功接收到一个或多个双精度值，将返回MPSUCCESS。如果发生错误或没有接收到数据，将返回其他错误码。
buff数组大小: buff数组必须足够大，能够至少容纳numdatapoints个双精度值。确保在调用此函数之前分配足够的空间来存储预期接收的数据。
简而言之，receiveMPData函数提供了一种从MP设备的守护进程中接收连续数据采集结果的高效方法。通过正确管理buff数组的大小和处理numreceived返回的实际接收数据量，开发者可以灵活地处理和分析采集到的数据。
 * */
MPDLL_EXPORT MPRETURNCODE _stdcall receiveMPData(double buff[], const DWORD numdatapoints, DWORD * numreceived);

/** Set the Analog Channels to Acquire
 *
 *	In order for data acquisition to start, at least one analog channel must be enabled for acquisition.
 *
 *	analogCH[<em>i</em>] = <em>true</em> implies that the MP device is set to acquire from Analog Channel <em>i</em>+1.
 *	\n
 *	analogCH[<em>i</em>] = <em>false</em> implies that the MP device is set to acquire from Analog Channel <em>i</em>+1.
 *	\n
 *	Where 0 &lt;= <em>i</em> &lt; number of analog input channels of the MP device.
 *
 *	\note
 *		- The length of <em>analgoCH</em> array must equal to the number of analog input channels of the MP device
 *
 *	\param analogCH an array of booleans, which enables/disables acquisition on the corresponding analog input channel
 *
 *	\return <em>MPRETURNCODE</em>
 */
/*
// setAcqChannels函数用于设置哪些模拟通道将被用于数据采集。为了开始数据采集，至少需要启用一个模拟通道。以下是参数的详细解释：
// analogCH (bool[]): 这是一个布尔类型的数组，用于启用或禁用相应的模拟输入通道上的采集。数组中的每个元素代表一个模拟通道，其中true表示启用该通道的数据采集，false则表示禁用。
//
// 如果analogCH[i] = true，表示第i+1个模拟通道被设置为启用，将从该通道采集数据。
// 如果analogCH[i] = false，表示第i+1个模拟通道被设置为禁用，不会从该通道采集数据。
// 其中，i的取值范围为0到MP设备模拟输入通道数目减1。例如，如果MP设备有16个模拟输入通道，则i的取值范围为0到15。
//
// 注意事项:
// analogCH数组的长度必须等于MP设备的模拟输入通道数目。这意味着你需要为设备上每个可能的模拟输入通道在数组中提供一个true或false值，即使你只使用其中的几个通道。
// 函数的返回值是MPRETURNCODE类型，这是一个枚举，用于指示函数调用的结果。如果成功设置了通道，则通常返回MPSUCCESS。如果设置失败，会返回一个指示具体错误原因的错误码。
// 这个函数是数据采集过程中配置设备的重要步骤，确保只有你想要采集数据的通道被启用，可以帮助优化数据采集的性能和效率。
 */
MPDLL_EXPORT MPRETURNCODE _stdcall setAcqChannels(const BOOL analogCH[]);

/** Set the Analog Channel Scaling
 *
 *	This function configures the linear scaling of the specified analog input channel. It determines the linear scaling and offset values using the two pairs of unscaled and scaled values.
 *	The linear scaling and offset are then applied to unscaled values read from the MP device internally. These scaled values are what is returned by the getMostRecentSample(), getMPBuffer(), and receiveMPData() functions.
 *
 *	\note
 *		- The usnscaled values are in the units of voltage, the native units of the MP device
 *		- The default scaling factor for analog input channels is one with an offset of zero
 *
 *	\param n the analog input channel where the scaling configuration will be applied and 0 &lt;= <em>n</em> &lt; number of analog input channels of the MP device
 *	\param unscaled1 the first unscaled voltage value
 *	\param scaled1 the first scaled value
 *	\param unscaled2 the second unscaled voltage value
 *	\param scaled2 the second scaled value
 *	
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall setAnalogChScale(const DWORD n, const double unscaled1, const double scaled1, const double unscaled2, const double scaled2);

/** Set the Voltage of the Specified Analog Output Channel
 *
 *	\note
 *		- For the MP150/MP160, <em>maxvolt</em> = 10.0 and <em>minvolt</em> = -10.0
 *		- For the MP36R, constant voltage level output is not supported
 *
 *	\param value voltage to set the specific analog output channel, <em>minvolt</em> &lt;= <em>value</em> &lt;=  <em>maxvolt</em>
 *	\param outchan specify the output channel number, <em>outchan</em> = 1 or <em>outchan</em> = 0
 *	
 *	\return <em>MPRETURNCODE</em>
 *
 *	\warning
 *		For safety, always set analog output channels back to zero volts before the client program exits or physically power cycle the MP device.  If you do not set the voltage level back to zero the analog output channels may continue to output a non-zero voltage.
 */
 /*
 setAnalogOut函数用于设置指定的模拟输出通道的电压值。这个功能对于需要控制或模拟特定电压水平的应用场景非常有用。

参数详解:
value (double): 指定要设置的模拟输出通道的电压值。这个值必须在MP设备支持的电压范围内，对于MP150/MP160设备，最大电压值为10.0伏特，最小电压值为-10.0伏特。传入的电压值应该满足minvolt <= value <= maxvolt的条件。
outchan (int): 指定输出通道编号。对于大多数设备，outchan = 1或outchan = 0，表示选择第一个或第二个模拟输出通道进行电压设置。

注意事项:
电压范围: 对于MP150/MP160设备，支持的电压范围是-10.0伏特到10.0伏特。尝试设置超出这个范围的电压值可能会导致函数调用失败。
MP36R设备限制: MP36R设备不支持恒定电压水平输出，这意味着此函数不适用于MP36R设备。

函数返回值:
返回类型为MPRETURNCODE，这是一个枚举类型，用于指示函数调用的结果。成功设置指定通道的电压值通常会返回MPSUCCESS。如果设置失败，将返回一个错误码，指明具体的失败原因。
安全警告:
为了安全，强烈建议在客户端程序退出之前或在物理断电前，将所有模拟输出通道的电压值设置回零伏特。如果不将电压水平设置回零，模拟输出通道可能会继续输出非零电压，可能会造成意外风险或损害。
总结来说，setAnalogOut函数提供了一种控制MP设备模拟输出通道电压水平的方法，适用于需要精确电压控制的应用。使用时需要注意电压范围的限制，并且在程序结束时确保将电压恢复到安全水平。
  * */
MPDLL_EXPORT MPRETURNCODE _stdcall setAnalogOut(const double value, const int outchan);

/** Setup output mode for MP device
 *
 *	\note
 *		- Allow switching to different output modes of MP devices
 *		- One of MP36R Input channels may be redirected to Output Channel 0
 *		- to reset output signal to zero user should issue this command with parameter of OUTPUTGROUND
 *
 *	\param mode specify the output mode of MP36R device\n
 *	    if <em>mode</em> == <em>OUTPUTCHANNEL1</em> Redirect signal of Input channel #1 to Analog Output Channel 0\n
 *	    if <em>mode</em> == <em>OUTPUTCHANNEL2</em> Redirect signal of Input channel #2 to Analog Output Channel 0\n
 *	    if <em>mode</em> == <em>OUTPUTCHANNEL3</em> Redirect signal of Input channel #3 to Analog Output Channel 0\n
 *	    if <em>mode</em> == <em>OUTPUTCHANNEL4</em> Redirect signal of Input channel #4 to Analog Output Channel 0\n
 *	    if <em>mode</em> == <em>OUTPUTGROUND</em> Ground output signal\n
 *	
 *	\return <em>MPRETURNCODE</em>
 *
 *	\warning
 *		For safety, always set analog output channels back to zero volts before the client program exits or physically power cycle the MP device.  If you do not set the voltage level back to zero the analog output channels may continue to output a non-zero voltage.
 */
MPDLL_EXPORT MPRETURNCODE _stdcall setAnalogOutputMode (const MP3XOUTMODE mode);


/** Set the Digital Channels to Acquire
 *
 *	digitalCH[<em>i</em>] = <em>true</em> implies that the MP device is set to acquire from Digital Channel <em>i</em>.
 *	\n
 *	digitalCH[<em>i</em>] = <em>false</em> implies that the MP device is set to NOT acquire from Digital Channel <em>i</em>.
 *	\n
 *	Where 0 &lt;= <em>i</em> &lt; number of digital input channels of the MP device.
 *
 *	\note
 *		- The length of <em>digitalCH</em> array must equal to the number of digital input channels of the MP device
 *
 *	\param digitalCH an array of booleans, enables/disables acquisition on the corresponding digital input channel 
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall setDigitalAcqChannels(const BOOL digitalCH[]);

/** Set the State of the Specified Digital I/O Line
 *
 *	<em>true</em> = "high" = 1 = 5.0 volts (TTL high)
 *	\n
 *  <em>false</em> = "low" = 0 = 0.0 volts (TTL low)
 *
 *	\note	
 *		- The MP36R has dedicated input and output lines while the MP150/MP160 has auto-switching digital input and output lines
 *		- For the MP150/MP160, this function automatically switches the direction of all the Digital I/O lines to output
 *		- The MP36R has 8 digital output lines (digital lines 0 through 7)
 *		- The MP150/MP160 has 16 digital output lines (digital lines 0 through 15)
 *
 *	\param n the Digital I/O line to set  where 0 &lt;= <em>n</em> &lt; number of digital I/O channels of the MP device
 *	\param state if <em>true</em> the Digital I/O line will be set high, if <em>false</em> it will be set low
 *	\param setnow if <em>true</em> the function will send the setting to the MP device, if <em>false</em> it will not send settings until the function is called with <em>setnow</em> set to <em>true</em>.  This allows for multiple Digital I/O lines to be configured before they are sent to the MP device.
 *	\param opt this parameter is ignored unless <em>setnow</em> = <em>true</em>\n
 *	    if <em>opt</em> == <em>SET_LOW_BITS</em> only digital lines 0-7 are set.\n
 *	    if <em>opt</em> == <em>SET_HIGH_BITS</em> only digital lines 8-15 are set.\n
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall setDigitalIO(const DWORD n, const BOOL state, const BOOL setnow, const DIGITALOPT opt);

/** Set the Triggering Configuration
 *
 *	\note
 *		- By default the triggering is set to off
 *		- For the MP36R, the external triggering (<em>MPTRIGEXT</em>) can only be triggered via negative edge (<em>posEdge</em>=<em>false</em>)
 *		- For the MP150/MP160, digital input channel triggering (<em>MPTRIGDCH</em>) is not possible
 *		- Trigger <em>level</em> is in the scaled units
 *		- If the scaling, gain, or offset of the analog input channel trigger (<em>MPTRIGACH</em>) is modified after configuring the trigger settings, the trigger <em>level</em> is recalculated as follows:
 *			- the previous level is used, regardless of the previous scaling units
 *			- if the previous level is out range of the new Scaled Input Range (see getChScaledInputRange()), the previous level will be clipped to the new range's maximum or minimum value
 *
 *	\param option different ways to set up triggering must use <em>TRIGGEROPT</em> enumerated values.\n
		if <em>option</em> == <em>MPTRIGOFF</em> the rest of the parameters are ignored by the function. \n
	    if <em>option</em> == <em>MPTRIGEXT</em> the TTL external trigger will be used, parameter <em>posEdge</em> is required and the rest of the parameters are ignored by the function.\n
	    if <em>option</em> == <em>MPTRIGACH</em> one of the analog channel inputs will be used and all the parameters are required by the function.\n
		if <em>option</em> == <em>MPTRIGDCH</em> one of the digital channel inputs will be used, all the parameters are required by the function except <em>level</em>. The <em>level</em> parameter is ignored.  It is automatically set to TTL.\n
 *	\param posEdge if <em>true</em> the triggering is set for positive edge trigger, if <em>false</em> it is set for negative edge trigger. This parameter is ignored by the function if <em>option</em> is set to <em>MPTRIGOFF</em>.
 *	\param level the scaled units level of the trigger, minRange &lt;= <em>level</em> &lt;= maxRange (see getChScaledInputRange()). This parameter is ignored by the function if <em>option</em> is set to <em>MPTRIGOFF</em>, <em>MPTRIGEXT</em> or <em>MPTRIGDCH</em>.
 *	\param chNum the  channel where the MP device waits for the trigger. This parameter is ignored by the function if <em>option</em> is set to <em>MPTRIGOFF</em> or <em>MPTRIGEXT</em>.\n
		if <em>option</em> == <em>MPTRIGACH</em>  0 &lt;= <em>chNum</em> &lt; the number of analog channels of the MP device.\n
		if <em>option</em> == <em>MPTRIGDCH</em>  0 &lt;= <em>chNum</em> &lt; the number of digital channels of the MP device.\n
 *
 *	\return <em>MPRETURNCODE</em>
 */
MPDLL_EXPORT MPRETURNCODE _stdcall setMPTrigger(const TRIGGEROPT option, const BOOL posEdge, const double level, const DWORD chNum);

/** Set the MP Device Sample Rate
 *
 *	\htmlinclude samplerates.txt
 *
 *	\param rate MP device sampling rate in msec/sample
 *
 *	\return <em>MPRETURNCODE</em>
 *
 *	\warning
 *		 - Only use the sample rates listed above
 *		 - The number of active acquisition channels should not exceed the Maximum Recommended Number of Active Acquisition Channels, the acquisition may fail or not even start otherwise
 *		 - Unexpected results may occur if the incoming data are not transferred and processed as quickly and efficiently as possible
 */
/*
setSampleRate函数用于设置MP设备的采样率，具体参数如下：
rate (double): MP设备每个样本的采样时间，单位为毫秒/样本。这个参数定义了数据采集的频率，即每秒中采集的样本数。
 较低的值意味着更高的采样率。

函数返回值:
返回类型为MPRETURNCODE，这是一个枚举类型，用于指示函数调用的结果。成功设置采样率通常会返回MPSUCCESS。
如果设置失败，将返回一个错误码，指明具体的失败原因。

警告:
采样率选择: 只能使用函数文档中列出的采样率。这是因为MP设备或其驱动程序可能只支持特定的采样率设置，
 使用未列出的采样率可能导致数据采集不准确或设备无法正常工作。
活跃采集通道数: 活跃采集通道的数量不应超过推荐的最大活跃采集通道数。
 如果超过，数据采集可能会失败，或者根本无法开始。这是因为每增加一个活跃的采集通道，
 都会增加数据处理和传输的负载。在较高的采样率下，这可能超过系统的处理能力。
数据传输和处理效率: 如果采集的数据不能尽可能快速和高效地被传输和处理，可能会出现意外的结果。
 这包括数据丢失、延迟或采集系统的总体性能下降。确保系统有足够的资源和合理的配置来处理采集到的数据是非常重要的。
综上所述，设置采样率时需要考虑到MP设备的技术规范、系统的处理能力以及采集任务的具体需求。
 正确配置采样率和采集通道数对于确保数据采集任务的成功和数据质量至关重要。
 * */
MPDLL_EXPORT MPRETURNCODE _stdcall setSampleRate(const double rate);

/** Start the Acquisition
 *
 *	\note
 *		- At least one analog input channel must be enabled for acquisition
 *		- If a the MP device is configured to trigger, this function will not return until the trigger is received by the MP device
 *
 *	\return <em>MPRETURNCODE</em>
 */
 /*
startAcquisition函数用于启动数据采集过程。在调用此函数之前，至少需要启用一个模拟输入通道。以下是与此函数相关的注意事项和参数解释：
注意事项:
启用模拟输入通道: 在开始数据采集之前，至少需要启用一个模拟输入通道。这意味着你应该在调用startAcquisition之前，使用setAcqChannels函数来指定哪些通道将被用于数据采集。
触发模式: 如果MP设备被配置为需要触发才开始采集数据（例如，等待外部信号或特定事件作为开始采集的条件），则startAcquisition函数调用后，
  将不会立即返回。它会等待直到接收到触发信号。在触发信号到达之前，该函数会处于阻塞状态。

函数返回值:
返回类型为MPRETURNCODE，这是一个枚举类型，用于指示函数调用的结果。成功启动数据采集通常会返回MPSUCCESS。如果启动采集失败，会返回一个错误码，指示失败的具体原因。
该函数没有参数。它直接操作之前通过其他API调用（如setAcqChannels）配置好的设备设置。

简而言之，startAcquisition函数是在完成所有必要配置（如启用所需的模拟输入通道）之后，用于开始数据采集的关键函数调用。如果你的设备设置了触发模式，那么在触发条件满足之前，这个函数会暂停执行。
  * */
MPDLL_EXPORT MPRETURNCODE _stdcall startAcquisition();

/** Start the Acquisition Daemon
 *
 *  Starts a thread (daemon) that downloads the data from the MP device and caches it once acquisition starts.  The cache can be retrieved by calling receiveMPData().
 *
 *	\note
 *		- call this function first before calling startAcquisition()
 *		- when using this function, you must <b>NOT</b> use any data transfer methods such as, getMPBuffer() and getMostRecentSample() functions, during the same acquisition
 *		- the daemon will not exit until the stopAcquisition() or disconnectMPDev() function is called or an error occurs within the thread
 *		- the thread is spawned from the calling process
 *
 *	\return <em>MPRETURNCODE</em>
 */
 /*
 startMPAcqDaemon函数用于启动一个守护进程（或称为线程），该守护进程在数据采集开始后负责从MP设备下载数据并将其缓存。然后，可以通过调用receiveMPData()函数来检索缓存中的数据。

注意事项:

启动顺序: 在调用startAcquisition()函数开始数据采集前，首先需要调用此函数。这是为了确保守护线程先于数据采集过程启动，从而准备好接收和缓存数据。
禁用其他数据传输方法: 使用此函数时，不得在同一次数据采集过程中使用getMPBuffer()和getMostRecentSample()等其他数据传输方法。因为这些方法可能会与守护线程的数据下载和缓存机制冲突。
守护线程退出条件: 守护线程将一直运行，直到调用stopAcquisition()停止数据采集、调用disconnectMPDev()断开与MP设备的连接，或者线程内部发生错误为止。这意味着守护线程的生命周期与数据采集或设备连接的状态紧密相关。
线程归属: 守护线程是从调用此函数的进程中产生的，这意味着守护线程与启动它的进程在同一进程空间内运行，共享进程资源。
函数返回值:

返回类型为MPRETURNCODE，这是一个枚举类型，用于指示函数调用的结果。成功启动守护线程通常会返回MPSUCCESS。如果启动失败，将返回一个错误码，指明具体的失败原因。
总的来说，startMPAcqDaemon函数为高效、连续的数据采集提供了一个后台数据处理机制。通过使用守护线程来下载和缓存数据，应用程序可以更灵活地控制数据处理流程，特别是在需要处理大量连续数据时。然而，使用此函数也需要遵循特定的规则和约束，以避免数据处理上的冲突和问题。
  * */
MPDLL_EXPORT MPRETURNCODE _stdcall startMPAcqDaemon();

/** Stop the Acquisition
 *
 *	\return <em>MPRETURNCODE</em>
 */
 /*
 stopAcquisition函数用于停止数据采集过程。这个函数在数据采集完成后调用，用于停止MP设备上的数据采集活动。

函数返回值:

返回类型为MPRETURNCODE，这是一个枚举类型，用于指示函数调用的结果。成功停止数据采集通常会返回MPSUCCESS。如果停止采集失败，将返回一个错误码，指明具体的失败原因。
这个函数没有参数，它直接作用于之前通过startAcquisition或相关函数启动的数据采集过程。在数据采集任务完成或需要终止采集时调用此函数，可以确保MP设备从采集状态恢复到正常状态，准备进行下一次采集或安全关闭设备。

使用stopAcquisition函数是管理数据采集过程的重要一环，确保数据采集能够按照预期安全地开始和结束。在多次数据采集任务之间，或在程序结束前调用此函数，是一个好的实践，可以帮助避免资源泄露或设备处于不确定的状态。
  * */
MPDLL_EXPORT MPRETURNCODE _stdcall stopAcquisition();

#ifdef __cplusplus
}
#endif

#endif
